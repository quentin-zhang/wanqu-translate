这篇文章和实验是由迈克尔Farinacci合作(负载测试),尼克•戈登(Ruby)伊恩•麦金尼斯(芬兰湾的科特林)和凯文Steuer(去)。 
 我们的团队一直肩负着为WeWork建立下一代的身份基础设施。与预期的速率WeWork及其兄弟企业增长,重要的是,这个新系统是高效、全球分布式的、可扩展的,允许合理的进化需求的变化在未来几年。 
 基于这些挑战,团队认为值得投入时间比较构建microservices可用的语言和软件栈。我们有三个候选人语言:走,芬兰湾的科特林和Ruby。比较是由建筑相同的现实身份系统的每个组件。我们选择一个令牌薄荷服务,生产不记名令牌更新和访问令牌OAuth2建立基础设施。每种语言有先例在WeWork其他系统建立,和每一个实现都是由开发人员的语言经验。 
 在完成这些实现,而在接下来的定性和定量指标的团队: 
 最终,这样的一个实验不能完全科学——软件工程是受到社会因素的影响,科学和数学。我们的目标主要是选择一个好的全能型选手的语言和工具集,团队将舒适与未来五年合作。 
 服务选择这个练习是一个“令牌薄荷糖”,产生三种类型的不记名令牌:刷新令牌访问令牌,令牌“行动”。隔离令牌生产和验证到它自己的服务可以帮助隔离使用密钥,是系统安全的关键。 
 刷新和访问令牌由该服务通常OAuth2语义:刷新令牌不到期,但可以撤销,并用于生产18小时后访问令牌到期。“行动”令牌是一个非标准的组成部分;访问令牌交换行动令牌的一个外部API调用。我们将执行这个交换使用的请求拦截器API网关(我们使用香港),以帮助减少风险意外或恶意的令牌在下游服务行为日志记录或漏出。 
 产生的令牌值,从其他的角度系统或客户,只是url-safe ASCII字符串。然而,他们所做的内部结构。他们是Base64编码的二进制协议缓冲区,包含令牌元数据和数字签名。在实验中使用的签名算法ECDSA,NIST的p - 256曲线。 
 服务提供了五个操作标识系统的其他授权的组件,在gRPC: 
 服务很简单实现由一个工程师,在几周内,代表我们必须建立真正的系统: 
 这种性质的系统主要是I / O绑定和执行数据库和查询在网络上写道。最计算密集型操作数字签名的生成和验证。生产和验证令牌的元数据和协议缓冲区计算相比微不足道。 
 一个负载测试客户机中实现,产生的服务定义使用gRPC客户机存根。负载测试模拟人口的用户与系统的交互,给定一个预期的使用模式的合理近似值。 
 对于一个用户,我们可能期望(平均)一个刷新令牌请求每六个月,每天一个访问令牌请求,和一个动作令牌请求每小时。将这些假设与模拟人口规模p产生估计的平均负载系统:l(p)= p×2.894×10⁻⁴每秒请求,95%的这些请求行动 
 n令牌的请求。给定一个人口规模的100 k用户,负载测试会产生大约每秒29令牌请求。通过调整模拟人口规模和/或并行运行多个负载测试流程(在不同的机器上,如果有必要的话),服务上的负载调整。 
 负载测试客户机记录每个请求的往返时间以微秒为单位,和任何错误发生。这些信息被用来产生请求散点图,柱状图等统计数据。我们可以告诉当服务开始时达到比例限制其平均延迟和/或第90个百分位开始明显上升,这通常表示某种形式的资源缺乏。 
 数据库开始节流吞吐量的人口规模大约在150万年,我们在100万年实现的性能相比。在这个人口规模,负载测试客户机试图产生的平均289.4每秒的请求。最有趣的统计数据: 
 在这里,我们可以看到每一个实现都提供了非常相似的平均响应时间,在几毫秒内。然而,芬兰湾的科特林实现开始表现出明显恶化第95和第99百分位延迟;我们推测,这可能是由于所涉及的上下文切换网络之间传递数据,协同程序执行和JDBC查询实现使用线程池。这种上下文切换是不必要的去和Ruby实现。同样清楚的是,所需的计算时间的三个实现处理所提供的负载。Ruby的CPU使用率统计数据可能是有点误导,错误的请求(~ 3%)产生最小影响CPU使用率:任何实际处理之前请求被拒绝。 
 尽管我们可能有偏见,很明显,每个堆栈完全有能力实现性能敏感的服务。每个实现,用一个容器在适度的硬件上,能够处理人口规模,我们不希望看到在WeWork直到2021年,并可能处理更多的优化我们的数据库使用模式。 
 Ruby的使用本机代码最计算密集型的部分实现意味着其解释性质不明显;只有Ruby gRPC实现的质量让它下来。去实现似乎是最有效的三个实现,最可预测的性能特征,我们增加了服务上的负载。 
 所有三个实现可能会进一步优化——这些负载测试结果没有产生具体的尝试配置文件或提高性能的实现。实现站,去有一个轻微的边缘。JVM有最好的工具来分析和最配置选项运行系统的挤压性能,但这样的优化是脆弱的;最好是投资在架构级别的性能优化。 
 总的来说,我们的表现平庸的结论与方法的选择多语言的选择。可以实现良好的性能在任何堆栈,由技术熟练的工程师了解其细微差别。 
 去,通过团队的多数票。芬兰湾的科特林位居第二,Ruby第三。是更好的技术选择的团队感到有以下原因: 
 这个选择带有强烈的警告,我们必须提供规则或建议: 
 以下部分是每个实现的深入讨论,每个具体的各种利弊进行了讨论。 
 芬兰湾的科特林是一个静态类型,object-functional JetBrains设计的语言,于2011年首次发布。它主要是编译为JVM字节码,但实验支持编译本地二进制文件(通过LLVM),和transpiling Javascript。 
  
 我们作为芬兰湾的科特林更灵活,更少的冗长的替代Java,和一个简单的替代Scala。它已经迅速在Android生态系统越来越流行,它现在支持谷歌作为Android应用程序和库的一等公民。 
 三个关键决策是在芬兰湾的科特林实现,有强烈影响的结构生成的代码,并可能对性能: 
 芬兰湾的科特林是一个不错的全能型选手语言:语言与Ruby的表现力,同时保留强大的静态类型安全。其语言特征允许更紧凑,表达比Java代码,没有过于固执己见的OOP和FP的二分法。这种语言的灵活性尤其适合建筑领域特定的抽象来帮助解决问题。这也是一个Ruby的核心力量,也可以说是一个核心的弱点。 
 扩展方法是一个很好的特性,帮助与代码的可读性。“流利”风格的编程方法链接可以很容易地添加到现有类型通过使用扩展方法,我们好好利用在实施建筑商和验证器缓冲消息的协议。 
 直接互操作与JVM库、工具和框架也是一个核心力量:Java程序员可以在几分钟内开始在芬兰湾的科特林,即使他们不适应他们的编程风格,包括功能模式,他们可以看到有意义的生产率增长。也难怪芬兰湾的科特林有一个优秀的IDE,鉴于其在JetBrains起源。 
 而灵活、务实的态度,函数式编程在芬兰湾的科特林是一个截然不同的力量,它也可以被看作是一个弱点:很容易得意忘形的功能性风格,和读代码标记结束。这件事发生在我们的实现与使用箭头图书馆太深——等效命令代码时可能会更长,它可以更容易理解和更少的微妙。 
 作为一个相对较新的语言让程序员广泛的语言工具,没有完善的使用语言的最佳实践。结果,这将导致非常不同的编码风格和方法问题跨项目、团队和个人。去和Ruby,相比之下,有更成熟的习语。 
 一些尴尬的问题被发现在使用芬兰湾的科特林协程,这仍然是一个实验性的语言的一部分。特别是,与箭头的组合协同程序类型单子理解是很困难的。箭头的EitherT单子变压器帮助但有点神奇的门外汉。 
 一些核心Java api开始展示他们的年龄,,不适合当代的异步编程。JDBC是一个典型的例子:操作获取数据库连接和调度查询都是阻塞操作。直到异步继任者JDBC可用,JDBC调用必须通过一个单独的线程池来避免阻塞线程协同程序。 
 是静态类型的,命令式的语言,2009年首次发布的谷歌。这是出于需要解决大规模的软件工程问题在谷歌,和通常是编译静态链接本地二进制文件。 
 我们认为作为一个当代的替代C / c++,保留语言简洁,同时提供内置的垃圾收集和异步编程原语等必需品。去被许多工程组织采用后端系统,包括乳房松弛,Dropbox,抽搐。 
 我们使用了grpc框架,利用go-grpc-middleware,处理我们共同的基础设施模式处理恐慌,opentracing,请求属性验证。这导致了一个干净的常见服务器模式,我们可以重用在microservices。 
 对于我们的图书馆我们采用功能选项模式智能违约,灵感来自戴夫Ch 
 eney的博客文章和gRPC。 
 长处是在为什么我们选择去,有几个额外的原因: 
 实现最大的工具遇到的难点是在使用go-sqlmock数据库单元测试。最初的SQL语句写MYSQL风味vs Postgres,才发现集成测试运行。另一种方法可能是使用一个内存中的db数据库,postgres协议。 
 错误可以说是太简单,错误检查似乎乏味和代表的很大一部分代码。这导致团队想出自己的错误类型或策略。 
 碎片的依赖管理工具要采用哪一种会导致混乱。去模块最近出货在1.11这可能完全解决。 
 Ruby是动态类型的,面向对象的,解释的脚本语言。在1995年首次发布Yukihiro“Matz”Matsumoto,还积极参与的设计语言。Ruby解释器的写在C和Ruby,包的能力(称为“宝石”)包括原生扩展,如C,c++,或者生锈。 
 我们认为Ruby是一个更灵活的动态类型语言,公司拥有大量的经验。WeWork的大部分应用程序(截止2018年6月)是用Ruby编写的,主要使用Ruby on Rails。 
 没有使用的Ruby实现框架,但是代码被组织在一个时尚,熟悉Ruby on Rails开发人员(模型、控制器、服务等)。由于简单的数据模型,编写了一个简单的包装pg宝石,而不是使用activerecord或其他刀/ ORM库。 
 我们使用gruf BigCommerce写的,管理gRPC请求。它抽象出的大多数boilerplate-level担忧与管理GRPC服务器同时还暴露底层配置如果需要。 
 异步性处理完全在服务器级——每个请求运行在它自己的线程从控制器到数据库调用。翻译有一个全局锁,因此更复杂的线程通常不是惯用应用层Ruby代码。这可能更容易导致交替实现规模水平。 
 码头工人图像明显更大(类似部署映像使用高山仍然是2.5 x芬兰湾的科特林或容器的大小),但这不是一个巨大的差异在大多数部署因为只有初始拉编排将处理网络时间。 
 Ruby gRPC服务器(使用官方库)没有队列请求(因为这个pr)的合并,这意味着负载较重的情况下,它将拒绝许多传入的请求。 
 作为测试套件的一部分,集成测试写的容易包作为其他实现的验收测试套件的套件。RSpec很好支持,容易扩展,而生产可读失败non-ruby开发者。 
 在这个项目中的数据库逻辑简单,作者没有感觉有必要做任何事情更复杂,基本Ruby postgres宝石,更复杂的数据库项目可以切换到使用ActiveRecord和利用ORM使Rails如此强大。 
 虽然OpenTracing没有添加到该项目在撰写本文时,添加在NewRelic跟踪和监控要求添加一个简单的Gruf拦截器。额外的仪器也需要调整和添加最小修改代码。 
 大部分的消息内容为该项目在字节和加密。 
 处理uuid作为字节并不难做,但不是一等公民。这需要写一些辅助方法,简单写但是是一个额外的开销在这样的一个项目。 
 密文 
 y在Ruby中通常是通过系统库(Ruby氯化钠或OpenSSL),但这个项目特别指定的叮叮铃。自从叮叮铃还没有实现在Ruby中(仅在c++、Java和这篇博文的时候),多个进口和处理程序需要与其他实现匹配。 
 主要难点Ruby的语法生成的代码已经解决的写作分析:ruby_package现在可以用于声明名称空间动态,使Ruby代码更地道(释放和gRPC公关)。 
 有兴趣加入我们的团队吗?WeWork招聘软件工程师在特拉维夫,纽约和旧金山。视图开口 
 可能写了一些代码的地方 
 我们相信有一个宏观转向今天的工作的新方式——一个专注于运动的意义。WeWork技术自豪是加速运动。有兴趣加入吗?https://www.wework.com/careers/department/technology 
  
   
  URL : https://engineering.wework.com/choosing-a-language-stack-cac3726928f6?utm_source=wanqu.co&utm_campaign=Wanqu+Daily&utm_medium=website