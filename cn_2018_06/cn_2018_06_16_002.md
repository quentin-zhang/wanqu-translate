注意:我最初撰写这篇文章在微软与文森特拉(工程师主要负责工作在这里描述OneNote),决定重新发布这个版本以来,这个论坛似乎不再可用。文森特感谢所有的详细信息和反馈! 
 有一个古老的谚语在软件工程——“从来没有编写您自己的数据库”。那么为什么OneNote团队继续编写一个升级OneNote本地缓存实现的一部分吗? 
 首先,它可能需要更仔细地定义什么是“数据库”在这种情况下。 
 最有趣的应用程序需要能够坚持他们的应用程序状态和用户内容创建和管理持久存储。应用程序可以使用自己的自定义逻辑持久性或利用一些已存在的数据库管理软件(数据库管理系统)来处理其数据存储。现有的DBMS可能是某种关系存储(例如SQLLite这样,ESENT)或一个简单的键值存储(或频繁,关系存储用作键值存储)。 
 如果你开始探索这些技术,它不需要太多时间浏览维基百科页面ESENT(例如)了解的一些复杂性参与构建一个数据库。虽然阅读描述,你几乎可以做一个考古分析是什么最初的核心功能和附加功能是什么发展随着时间的推移,显然从不断变化的客户需求(聚集索引,稀疏索引,索引、版本列,等等。)。它提供清晰的感觉到这是一个组件,它经受住了时间的考验,成为一些关键的基础产品,以及他们如何在市场上发展的。 
 有两种,而平衡反应在评估是否使用这样一个健壮的和功能组件。第一反应是“天哪,没有办法,我足够聪明来复制技术”!这是一个很好的和公义的反应!“如果我看到到目前为止,那只是因为我站在巨人的肩膀上……” 
 另一个反应是:“哇,这里有很多东西,我不需要。我想知道我付了吗?“工程的关键原则之一是TANSTAAFL——“没有没有免费的午餐”。最终,当你看到在后台,额外的功能和额外的代码实现,IO、内存和CPU,就像如果你实现它自己。有时(很少)完全到手,你只支付当你使用这些额外的成本特性。其他时候组件的实现建立在特定的假设和权衡,这些功能可能会限制未来进化或地方限制组件是如何集成到一个更大的系统。甚至是分析的复杂性,当你理解了核心组件的设计特点,这常常会导致建立一个完整的实践功能原型来验证您的特定性能需求下自己的模拟负载模式(或实际)。 
 让我们回到应用程序状态持久化的问题。 
 有些应用程序运行在一个相对简单的存储方式。磁盘上的文件是完全在内存中读取到数据结构,修改,然后整个文件是写回到磁盘。一个简单的写作技巧的新文件在一个单独的名称,然后重命名新文件替换旧文件被成功之后才写提供安全与存储腐败。 
 下一个方法是使用多个文件在磁盘上代表应用程序的状态;加强在复杂性非常陡峭。一个重要挑战是,一般的文件之间存在相互依赖关系(如某种指数)和文件系统一般不提供任何事务担保(或权衡使用th的支持 
 是做提供太大)。面对失败(保证发生在规模)的状态不同的文件可以变得不一致。这意味着应用程序必须建立在识别和修复的技术不一致的“破坏”状态。独立的事实文件通过文件系统访问其他应用程序和服务也使得这种矛盾状态,需要设计。然而,与任何一个文件可以仍然相对简单,只需要打开在托托和重写它。总的来说,可能还有其他挑战取决于杠杆规模的文件系统(例如,如果10年代,100年代,1000年代的文件可能需要管理和跨越目录优化文件系统性能特征,规模与数量的文件/目录)。这种方法使用独立的文件可以独立工作当文件是一致的,典型的文件大小是足够大的存储空间效率不是特别关注(由于碎片或浪费的空间由于文件系统元数据和页面大小)。使用能够满足这些需求的一个例子是存储邮件附件为独立文件在磁盘上而不是在单个邮件缓存文件。存储大型独立气泡问题文件系统已经调整了,所以这个卸载可以缩小范围的设计点需要针对单个文件数据库。 
 关键微分方法在数据库中我使用这个词是单一文件只是部分读取到内存中,只有不断改写。例如,电子记事本提供了虚拟体验在一个潜在的很大的空间(10 s(GBs)的笔记本。他们不能完全加载到内存和应用程序想提供错觉,所有可用的数据浏览和编辑。应用程序想迅速引导到工作状态(也就是说,在启动时只做少量的IO)。修改通常只涉及数据和应用程序的一个小子集想写这些更改磁盘快速和低成本。当我浏览超过新部件的数据模型,我想很快的错,数据(例如导航到一个新的部分OneNote)。额外的要求是,虽然大多数写的是小和增量,同步新内容的特殊情况需要非常快速且高效的批量转移。 
 即使有这相当简单的描述需求,我们已经有一些相互矛盾的约束(工程的本质!)。我们希望数据包装在一起我们可以减少IOs的总数量和规模,但我们希望避免重新打包在一起当储蓄的变化只有一小部分数据。如果我们只写更改的数据数据最终会随着时间的推移变得越来越分散,同时如果我们总是重新打包我们最终做更多的IO -本质上不得不重写数据没有改变为了得到更好的包装。一个根本的改变方法,我们看到在远离桌面AC-powered机器电池供电的移动设备(即权力限制)是远离这些权衡的假设我们可以处理一些通过零星的高成本的维护过程(例如运行整个文件压缩或碎片整理过程“3点”)。相反,稳态性能是需要重点和成本摊销。这已经是智能手机的崛起之前,我们假设我们运行代码的能力在这些时候怀疑(battery-constrained笔记本电脑成为主导在2000年代中期开始的;“绿色”AC-powered晚上机器会自动关闭;作为磁盘容量但IO每秒没有爆炸,只是重写所有的数据可能需要这么长时间,它可能在任何维护窗口,这是一个不完整的 
 不在)。 
 我们还需要考虑如何实现核心数据库ACID属性(原子性、一致性、隔离、耐用)。虽然是一个长期的技术历史的方法和技术,它们通常嵌入在具体的实现,而不是作为一组简单的api来调用。想滚你意味着加入一个神秘的巫师熟悉文件系统的阴谋深奥的知识包括真的是一个冲洗冲洗时,病毒检测程序可以做什么奇怪的事情,何时何地IO请求可以被重新排序,备份系统的工作原理,同步引擎如何工作,如何在不同操作系统类型,等等。 
 滚自己的优点是,你可以优化和控制水平的东西仅仅是通过一个复杂的外部组件工作时不可能的。在某种意义上这是永恒的组件依赖的问题。什么时候一个外部组件解决一个困难的问题比你自己吗?确定“更好”通常是一个困难的问题,其中包括等方面的性能,功能和开发时间/成本以及随着时间的推移“更好”的重要元素。将改变随着时间的推移,自己的需求,你的视图的重视你的产品优化这一层将会改变,景观将改变底层技术,组件本身会改变(或频繁,不会改变,这是有问题的,当之上,改变技术景观)。 
 好的,那都只是背景。让我们深入的细节OneNote工作。 
 OneNote已经一段时间变成一个纯粹的云应用程序和数据存储在云端文件存储在本地磁盘上而不是操作。这项工作是集中在优化OneNote“缓存”——的一组文件存储在本地缓存副本云笔记本支持离线使用和快速响应性的读和写。最初的OneNote持久化格式存储在一个单独的每个部分文件(其中每个部分包含一组页)。一个笔记本被表示为一个文件夹层次结构,其中包含部分文件和其他文件夹。一个内容文件表存储某些关于文件夹本身的元数据。电子记事本的原始格式合并所有缓存的笔记本电脑缓存到磁盘上的一个文件。部分文件是“数据库”的含义在这里我们使用(它设计的部分读和增量地重写)和缓存文件之上的核心文件和对象管理原语用于阅读和写作部分文件。 
 缓存重写工作有明确的目标,一个重要的约束。正如上面我提到的,电子记事本的缓存文件旨在周期性大规模清理进程运行,并不适合在移动资源受限的世界。所以一个重要目标是消除任何需要定期保养,这样在实际使用缓存将会使用更少的存储和需要更少的内存和CPU(因为许多设备维护从未成功地运行)。另一个相关的目标是解决长期低效OneNote revision-based存储模型。OneNote支持一个“减少储蓄”模式,所有更改会自动保存到存储。为了有效地做到这一点,它附加新修订的页面只包含更改的内容。大量编辑页面(一个虽小但非常宝贵的子集),这些修订链可以变长,导致页面加载慢,需要更多的内存和CPU。成本的一个重要目标是确保加载一个页面符合实际的页面呈现给用户的复杂性而不是正比于它的编辑历史。 
 的重要约束,工作应该是有限的存储层本身,而不是需要大量重写整个应用程序。这最终促使许多需求。当dealin 
 g大型的、复杂的系统中,一个关键问题是如何演化架构没有把所有悬而未决,希望它的土地。这种方法是一个过去的事情在我们的世界里不断的工程和交付。事实上,即使在过去是有问题的,因为它递延的许多棘手和耗时的集成任务,许多项目后期的来源。 
 在电子记事本的案例中,这种增量的方法开重要的要求: 
 团队仔细地看了一下现有的数据库解决方案(记住古训从来没有编写自己的数据库呢?)。最终真的是上面列出的集成需求,把他们写自己的数据库,而不是在原始性能或鲁棒性分析的结果。这些类型的评估非常棘手,因为你可以在两个方向上都失败了——你可以低估成本稳定自己的低级代码在野外的世界真正的机器和使用模式或者你可以低估提供完整解决方案的成本上现有复杂的组件,有自己的设计点和约束,特别是如果你并不是从零开始,而是试图与现有组件约束约束自己的应用程序。团队是建立在其建立的专业知识在这个空间给他们信心,让他们有一个好的理解的陷阱在建立自己的。 
 最早的一个决定他们是把缓存到一个单独的文件/页面(只有一个主索引文件)。垃圾收集空间分配给删除页面和删除内容或关闭笔记本被单一文件缓存设计的一个重要问题。通过分割页面,这垃圾收集问题卸载文件系统,这是高度调整来解决它。此外,单个页面的典型尺寸相对较小(虽然符合大小的文件系统调优),打开其他简化的机会。有其他好处——它也避免问题出现了缓存文件特别大(> 4 gb)。偶然地,它还集成了企业数据保护api(一个新的Windows 10特性)更简单的因为每个页面可以单独加密根据适当的政策内容。我说“意外地”,但实际上这是一个很好的例子,有一个低级设计更符合用户的高水平模型的内容最终避免内部实现复杂性和价值不一致。这是一种“偶发复杂性”,可以减缓发展随着时间的推移,在大型代码库。 
 正如上面提到的,这并引入一个单独挑战多文件一致性。这里的团队花了一个有趣的方法。索引文件指向页面的根图形的位置和自由空间地图在每个页面缓存文件。坚持一个多文件的事务时,所有页面缓存文件索引文件之前刷新到磁盘。每一页文件现在有两个图根(及其相关的自由空间地图)新旧图图(通常有许多孩子)。都是完全一致的,可用的文件,根据你开始寻找。然后刷新到磁盘索引文件指向新的图根和免费地图。事务一致性的创建和删除页面需要一个额外的小麻花。索引文件的数据结构(刷新到磁盘作为交易的一部分)描述了文件删除和创建的文件。新创建的文件在一个单独的文件夹,然后搬到主缓存文件夹在事务完成后。重新启动,这些数据结构处理,以确保任何行动,没有完全完成最后运行完成。 
 删除是幂等(删除多次导致相同的结果),所以相当简单。敲定创建事务也是幂等(子文件夹中的任何文件不再已经成功地搬到主文件夹)和文件中引用出现在子文件夹而不是建立一个未完成的新页面列表相关事务,可以安全地删除(或可用的“失去的页面”恢复功能)。 
 地址修改长链的问题,他们犯了一个根本性的变化在页面级的数据结构。页面仍然定义为修正链,但是现在每个修订商店查找表(现在BTree)修订的所有对象引用。旧版本只引用改变对象的修改,需要走在修订明确找到任何对象链修订并没有改变。 
 成本的影响是,页面加载的一个版本(尤其是当前版本)现在反映复杂的页面,而不是它的编辑历史。这种变化使计算修正不同之间的变化。如上所述,这是其中的一个操作系统的假设快得多。团队花了相当多的时间重新设计差分算法(包括构建一套更广泛的单元测试和组件测试),以确保它的可靠性和性能特征,系统的其他部分,尤其是在一个广泛的一组用例。这是另一个很好的例子,投入很多努力(及周边工程基础设施,确保财产维护产品随着时间的推移演变)在一个特定的特性——计算两个页面版本之间的区别,这样系统的其余部分可以写假设它是可靠的和快速的。事实上,通过编写差分算法一般能力比较任意两个修订,而不是假设链接关系,它打开了其他用途的特性(例如用户级比较无关的页面版本通过简单修改链接但更复杂的分支)。 
 快速页面快照是另一个新实现的功能要求。事务一致性机制,需要有多个实例页面的图是有效的同时还可以支持一个健壮的快照机制(只要继续坚持两个实例修改页面的图在事务的范围)。通过构建对整个缓存事务机制也扩大了快照的功能从单一页面在旧系统允许整个笔记本的快照。这不是一个机制,目前正在使用但有多个功能在早期阶段的规划考虑更充分利用这个功能。 
 支持多种作家允许事务进行独立但都合并成一个单独的事务提交时。这取决于利用电子记事本的健壮的合并功能,包括能够代表直接冲突的编辑内容模型。有一些情况下,内容模型不能合并,在这种情况下,事务支持。结合写事务有一个长时间运行的事务的结果可以从提交延迟其他事务所以需要注意如何使用这种机制更高级别的流程(如同步)。 
 他们带的一个关键方法来减少内存使用页面缓存的内存映射文件的数量,减少额外的数据结构需要分配和维护以代表页面在内存中。这存储层都需要更少的内存和CPU自存储数据结构可以直接引用没有额外的配置和数据复制。 
 OneNote通常构建一个内存中的存储结构的图易于操纵。这个团队现在正看着更多的机会,某些处理(特别是批量操作,比如同步和索引非常具体的功能需求)可以直接在存储层实现,而不需要一个图表“水分”。经验表明,这样的优化是令人惊讶的有效的。 
 从长远来看,这些变化在灵活的线程模型和高效处理模型集OneNote建立在他们的投资在持有低级存储层。OneNote团队,看来很清楚的是,至少在这种情况下,那句老话证明是错误的。 
 从一个快速起立鼓掌欢呼,鼓掌能表示你吃得多喜欢这个故事。 
  
   
  URL : https://medium.com/@terrycrowley/never-write-your-own-database-736f704c780?utm_source=wanqu.co&utm_campaign=Wanqu+Daily&utm_medium=website